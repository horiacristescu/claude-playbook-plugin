#!/bin/bash
# state-echo-hook
# PostToolUse hook — shows the current gate from task.md.
#
# Reads the active task's task.md, finds first unchecked gate (- [ ]),
# echoes it with file:line so the agent can follow or edit.

set -e

# Source shared lib (same directory)
HOOK_DIR="$(cd "$(dirname "$0")" && pwd)"
source "$HOOK_DIR/gate-echo-lib.sh"

# Find project root — only matches .agent/tasks/ (playbook projects)
PROJECT_DIR=$(find_project_root)
if [ -z "$PROJECT_DIR" ]; then
    echo '{}'
    exit 0
fi

# Check writability for gate echo counter and transition logging
AGENT_WRITABLE=true
if ! agent_dir_writable "$PROJECT_DIR"; then
    AGENT_WRITABLE=false
fi

STATE_FILE="$PROJECT_DIR/.agent/current_state"

# Read stdin (PostToolUse JSON) — parse session_id for per-session state
INPUT=$(cat)
SESSION_ID=$(echo "$INPUT" | python3 -c "import sys,json; print(json.loads(sys.stdin.read()).get('session_id',''))" 2>/dev/null || echo "")
TOOL_NAME=$(echo "$INPUT" | python3 -c "import sys,json; print(json.loads(sys.stdin.read()).get('tool_name',''))" 2>/dev/null || echo "")

# Use per-session state file if available
if [ -n "$SESSION_ID" ]; then
    PER_SESSION_FILE="$PROJECT_DIR/.agent/current_state.$SESSION_ID"
    if [ -f "$PER_SESSION_FILE" ]; then
        STATE_FILE="$PER_SESSION_FILE"
    fi
fi

# Counter file (per-session, "default" fallback if no session_id)
COUNTER_SESSION="${SESSION_ID:-default}"
COUNTER_FILE="$PROJECT_DIR/.agent/.hook_counters.$COUNTER_SESSION"

# Increment tool/write counters
if [ "$AGENT_WRITABLE" = true ]; then
    TOOLS_VAL=$(read_counter "$COUNTER_FILE" tools)
    write_counter "$COUNTER_FILE" tools $(( ${TOOLS_VAL:-0} + 1 ))
    case "$TOOL_NAME" in
        Edit|Write|Bash)
            WRITES_VAL=$(read_counter "$COUNTER_FILE" writes)
            write_counter "$COUNTER_FILE" writes $(( ${WRITES_VAL:-0} + 1 ))
            ;;
    esac
fi

# Read task number
if [ ! -f "$STATE_FILE" ]; then
    echo '{"hookSpecificOutput":{"hookEventName":"PostToolUse","additionalContext":"# No active task (tasks work <N> to activate)"}}'
    exit 0
fi

TASK=$(head -1 "$STATE_FILE" | tr -d '[:space:]')

if [ -z "$TASK" ]; then
    echo '{"hookSpecificOutput":{"hookEventName":"PostToolUse","additionalContext":"# No active task (tasks work <N> to activate)"}}'
    exit 0
fi

# Find task file matching the task number
TASK_FILE=$(find "$PROJECT_DIR/.agent/tasks" -maxdepth 2 -name "task.md" -path "*/${TASK}-*/*" 2>/dev/null | head -1)

if [ -z "$TASK_FILE" ]; then
    CONTEXT="# [${TASK}] — task file not found"
    JSON_CONTEXT=$(python3 -c "import json; print(json.dumps('$CONTEXT'))" 2>/dev/null || echo "\"$CONTEXT\"")
    echo "{\"hookSpecificOutput\":{\"hookEventName\":\"PostToolUse\",\"additionalContext\":${JSON_CONTEXT}}}"
    exit 0
fi

# Count total and done checkboxes (only [ ], [x], [X] — not [8] reference links)
TOTAL_GATES=$(grep -cE '^[[:space:]]*- \[( |x|X)\]' "$TASK_FILE" 2>/dev/null) || TOTAL_GATES=0
DONE_GATES=$(grep -cE '^[[:space:]]*- \[[xX]\]' "$TASK_FILE" 2>/dev/null) || DONE_GATES=0

# Find first unchecked gate (only at line start)
GATE_LINE=""
GATE_TEXT=""

while IFS= read -r line; do
    LINENO_PART="${line%%:*}"
    CONTENT="${line#*:}"
    GATE_LINE="$LINENO_PART"
    GATE_TEXT=$(echo "$CONTENT" | sed 's/^[[:space:]]*- \[ \] *//')
    break
done < <(grep -nE '^[[:space:]]*- \[ \]' "$TASK_FILE" 2>/dev/null)

# Make path relative to project
REL_PATH="${TASK_FILE#$PROJECT_DIR/}"

# Repetition detection + gate transition logging (using consolidated counter file)
GATE_LOG="$PROJECT_DIR/.agent/chat_log.md"
REPEAT_MSG=""
TRANSITION_MSG=""
SKIP_MSG=""
if [ -n "$GATE_LINE" ]; then
    GATE_KEY="${TASK}:${GATE_LINE}"
    PREV_KEY=$(read_counter "$COUNTER_FILE" gate_key)
    PREV_COUNT=$(read_counter "$COUNTER_FILE" gate_count)
    PREV_TEXT=$(read_counter "$COUNTER_FILE" gate_text)
    if [ -n "$PREV_KEY" ] && [ "$PREV_KEY" = "$GATE_KEY" ]; then
        NEW_COUNT=$((PREV_COUNT + 1))
    elif [ -n "$PREV_KEY" ]; then
        # Gate changed — log the completed gate
        PREV_TASK="${PREV_KEY%%:*}"
        PREV_LINE="${PREV_KEY##*:}"
        TRANSITION_MSG="# ✓ previous gate done (${PREV_COUNT} tool calls)"
        if [ "$AGENT_WRITABLE" = true ]; then
            {
                echo "---"
                echo ""
                echo "**[G${PREV_TASK}:${PREV_LINE}]** [$(date -u '+%Y-%m-%d %H:%M:%S UTC')] \`HOST\` (${PREV_COUNT} tool calls)"
                echo ""
                echo "- [x] ${PREV_TEXT}"
                echo ""
            } >> "$GATE_LOG"
        fi
        # Gate-skip detection: new first-unchecked is above the just-completed gate
        if [ "$PREV_TASK" = "$TASK" ] && [ "$GATE_LINE" -lt "$PREV_LINE" ] 2>/dev/null; then
            SKIP_MSG="
# ⚠ Gate at line ${GATE_LINE} is still open above completed gate at line ${PREV_LINE} — reorder gates in task.md if working out of order."
        fi
        # Bare-checkmark detection: compare completed gate text with original
        BARE_MSG=""
        if [ -n "$TASK_FILE" ] && [ -n "$PREV_LINE" ]; then
            COMPLETED_LINE=$(sed -n "${PREV_LINE}p" "$TASK_FILE" 2>/dev/null)
            COMPLETED_TEXT=$(echo "$COMPLETED_LINE" | sed 's/^[[:space:]]*- \[[xX]\] *//')
            if [ "$COMPLETED_TEXT" = "$PREV_TEXT" ]; then
                BARE_MSG="
# ⚠ Gate closed with bare checkmark — append your outcome. (line ${PREV_LINE})"
            fi
        fi
        NEW_COUNT=1
    else
        NEW_COUNT=1
    fi
    if [ "$AGENT_WRITABLE" = true ]; then
        write_counter "$COUNTER_FILE" gate_key "$GATE_KEY"
        write_counter "$COUNTER_FILE" gate_count "$NEW_COUNT"
        write_counter "$COUNTER_FILE" gate_text "$GATE_TEXT"
    fi
    if [ "$NEW_COUNT" -ge 10 ]; then
        REPEAT_MSG=" (same gate ${NEW_COUNT}x — are you stuck? edit the gate or replan: ${REL_PATH})"
    fi
else
    # All gates done — log final gate if exists, clean up gate_* counters
    PREV_KEY=$(read_counter "$COUNTER_FILE" gate_key)
    if [ -n "$PREV_KEY" ] && [ "$AGENT_WRITABLE" = true ]; then
        PREV_COUNT=$(read_counter "$COUNTER_FILE" gate_count)
        PREV_TEXT=$(read_counter "$COUNTER_FILE" gate_text)
        PREV_TASK="${PREV_KEY%%:*}"
        PREV_LINE="${PREV_KEY##*:}"
        {
            echo "---"
            echo ""
            echo "**[G${PREV_TASK}:${PREV_LINE}]** [$(date -u '+%Y-%m-%d %H:%M:%S UTC')] \`HOST\` (${PREV_COUNT} tool calls)"
            echo ""
            echo "- [x] ${PREV_TEXT}"
            echo ""
        } >> "$GATE_LOG"
        # Clear gate_* fields (task complete), keep tools/writes
        write_counter "$COUNTER_FILE" gate_key ""
        write_counter "$COUNTER_FILE" gate_count ""
        write_counter "$COUNTER_FILE" gate_text ""
    fi
fi

CONTEXT=$(format_context "$TASK" "$DONE_GATES" "$TOTAL_GATES" "${GATE_TEXT}${REPEAT_MSG}" "$GATE_LINE" "$REL_PATH")
if [ -n "$TRANSITION_MSG" ]; then
    CONTEXT="${TRANSITION_MSG}
${CONTEXT}"
fi
if [ -n "$SKIP_MSG" ]; then
    CONTEXT="${CONTEXT}${SKIP_MSG}"
fi
if [ -n "$BARE_MSG" ]; then
    CONTEXT="${CONTEXT}${BARE_MSG}"
fi

# Format as hook JSON
JSON_CONTEXT=$(echo "$CONTEXT" | python3 -c "import sys,json; print(json.dumps(sys.stdin.read().rstrip()))" 2>/dev/null || echo "\"$CONTEXT\"")

cat <<EOF
{"hookSpecificOutput":{"hookEventName":"PostToolUse","additionalContext":${JSON_CONTEXT}}}
EOF
