#!/bin/bash
# stop-hook
# Stop hook — prevents agent from finishing when task gates are unchecked.
#
# Reads active task's task.md, counts unchecked gates (- [ ]).
# If any unchecked: exit 2 with message (blocks stopping).
# If all checked, no active task, or stop_hook_active: exit 0.

set -e

# Source shared lib (same directory)
HOOK_DIR="$(cd "$(dirname "$0")" && pwd)"
source "$HOOK_DIR/gate-echo-lib.sh"

# Find project root
PROJECT_DIR=$(find_project_root)
if [ -z "$PROJECT_DIR" ]; then
    exit 0
fi

# Read stdin (Stop JSON) — extract stop_hook_active and session_id
INPUT=$(cat)
STOP_ACTIVE=$(echo "$INPUT" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('stop_hook_active', False))" 2>/dev/null || echo "False")
SESSION_ID=$(echo "$INPUT" | python3 -c "import sys,json; print(json.loads(sys.stdin.read()).get('session_id',''))" 2>/dev/null || echo "")

# Safety valve: if already blocked once, allow stopping to prevent loops
if [ "$STOP_ACTIVE" = "True" ]; then
    exit 0
fi

STATE_FILE="$PROJECT_DIR/.agent/current_state"

# Use per-session state file when session_id is known
if [ -n "$SESSION_ID" ]; then
    STATE_FILE="$PROJECT_DIR/.agent/current_state.$SESSION_ID"
fi

# No active task — allow
if [ ! -f "$STATE_FILE" ]; then
    exit 0
fi

TASK=$(head -1 "$STATE_FILE" | tr -d '[:space:]')
if [ -z "$TASK" ]; then
    exit 0
fi

# Find task file
TASK_FILE=$(find "$PROJECT_DIR/.agent/tasks" -maxdepth 2 -name "task.md" -path "*/${TASK}-*/*" 2>/dev/null | head -1)

if [ -z "$TASK_FILE" ]; then
    exit 0
fi

# Count unchecked gates (only real gates at line start, not inside blockquotes)
UNCHECKED=$(grep -cE '^[[:space:]]*- \[ \]' "$TASK_FILE" 2>/dev/null) || UNCHECKED=0

if [ "$UNCHECKED" -eq 0 ]; then
    exit 0
fi

# Counter-gated bypass: allow stop for conversational replies (low tool activity)
# Missing counter file = assume work was done (block)
COUNTER_SESSION="${SESSION_ID:-default}"
COUNTER_FILE="$PROJECT_DIR/.agent/.hook_counters.$COUNTER_SESSION"
if [ -f "$COUNTER_FILE" ]; then
    WRITES=$(read_counter "$COUNTER_FILE" writes)
    TOOLS=$(read_counter "$COUNTER_FILE" tools)
    if [ "${WRITES:-0}" -eq 0 ] && [ "${TOOLS:-0}" -lt 5 ]; then
        exit 0
    fi
fi

# Find first unchecked gate for the message
FIRST_GATE=$(grep -m1 -E '^[[:space:]]*- \[ \]' "$TASK_FILE" 2>/dev/null | sed 's/^[[:space:]]*- \[ \] *//')

cat >&2 <<MSG
BLOCKED: ${UNCHECKED} unchecked gate(s) in task ${TASK}.

First unchecked: ${FIRST_GATE}

Complete all gates before finishing.
MSG
exit 2
